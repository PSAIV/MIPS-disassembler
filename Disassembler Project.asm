#Paul Adams 11/21/18
		.data		
FibData:	.word					0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				12,
				1750335520,
				1766203493,
				1634627426,
				543777635,
				1651340654,
				544436837,
				979726945,
				10,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0
				
FibText:	.word				537395200,
				537722928,
				2376925184,
				604635137,
				1176768512,
				2903113728,
				2903113732,
				564789246,
				2366308352,
				2366373892,
				23875616,
				2903113736,
				554172420,
				556400639,
				488701945,
				537133056,
				862240,
				201329684,
				604110858,
				12,
				278560,
				346144,
				537133110,
				604110852,
				12,
				2365849600,
				604110849,
				12,
				537133108,
				604110852,
				12,
				554172420,
				556400639,
				488701943,
				65011720


Offset:	.word					0,
				6,
				14,
				16,
				20,
				24,
				28,
				33,
				38,
				43,
				49,
				54,
				60,
				65,
				69,
				74,
				78,
				86,
				92,
				100,
				108,
				116,
				124,
				132,
				140,
				148,
				156,
				164,
				172,
				180,
				188,
				196,
				204,
				207,
				210,
				214,
				217,
				221,
				225,
				229,
				237,
				240,
				243,
				247,
				250,
				258,
				266,
				270,
				276,
				279,
				284,
				289,
				294,
				302,
				307,
				312,
				320,
				323,
				328,
				333,
				341,
				349,
				354,
				359
				
Name:	.asciiz					"Rtype",
				"Illegal",
				"j",
				"jal",
				"beq",
				"bne",
				"blez",
				"bgtz",
				"addi",
				"addiu",
				"slti",
				"sltiu",
				"andi",
				"ori",
				"xori",
				"lui",
				"Illegal",
				"Ftype",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"lb",
				"lh",
				"lwl",
				"lw",
				"lbu",
				"lhu",
				"lwr",
				"Illegal",
				"sb",
				"sh",
				"swl",
				"sw",
				"Illegal",
				"Illegal",
				"swr",
				"cache",
				"ll",
				"lwc1",
				"lwc2",
				"pref",
				"Illegal",
				"ldc1",
				"ldc2",
				"Illegal",
				"sc",
				"swc1",
				"swc2",
				"Illegal",
				"Illegal",
				"sdc1",
				"sdc2",
				"Illegal"
				
OffR:	.word					0,
				4,
				12,
				16,
				20,
				25,
				33,
				38,
				43,
				46,
				51,
				56,
				61,
				69,
				75,
				83,
				88,
				93,
				98,
				103,
				108,
				116,
				124,
				132,
				140,
				145,
				151,
				155,
				160,
				168,
				176,
				184,
				192,
				196,
				201,
				205,
				210,
				214,
				217,
				221,
				225,
				233,
				241,
				245,
				250,
				258,
				266,
				274,
				282,
				286,
				291,
				295,
				300,
				304,
				312,
				316,
				324,
				332,
				340,
				348,
				356,
				364,
				372,
				380

NameR:	.asciiz 				"sll",
				"Illegal",
				"srl",
				"sra",
				"sllv",
				"Illegal",
				"srlv",
				"srav",
				"jr",
				"jalr",
				"movz",
				"movn",
				"syscall",
				"break",
				"Illegal",
				"sync",
				"mfhi",
				"mthi",
				"mflo",
				"mtlo",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"mult",
				"multu",
				"div",
				"divu",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"add",
				"addu",
				"sub",
				"subu",
				"and",
				"or",
				"xor",
				"nor",
				"Illegal",
				"Illegal",
				"slt",
				"sltu",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"tge",
				"tgeu",
				"tlt",
				"tltu",
				"teq",
				"Illegal",
				"tne",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal",
				"Illegal"
				
RegistersOffset: .word				0,
				6,
				10,
				14,
				18,
				22,
				26,
				30,
				34,
				38,
				42,
				46,
				50,
				54,
				58,
				62,
				66,
				70,
				74,
				78,
				82,
				86,
				90,
				94,
				98,
				102,
				106,
				110,
				114,
				118,
				122,
				126,
				130,
				133,
				136,

				
Registers: .asciiz 				"$zero",
				"$at",
				"$v0",
				"$v1",
				"$a0",
				"$a1",
				"$a2",
				"$a3",
				"$t0",
				"$t1",
				"$t2",
				"$t3",
				"$t4",
				"$t5",
				"$t6",
				"$t7",
				"$s0",
				"$s1",
				"$s2",
				"$s3",
				"$s4",
				"$s5",
				"$s6",
				"$s7",
				"$t8",
				"$t9",
				"$k0",
				"$k1",
				"$gp",
				"$sp",
				"$fp",
				"$ra",
				"pc",
				"hi",
				"lo"
				
Nop: .asciiz 					"nop"
Illegal:	.asciiz 			"Illegal"
DataLabel: .asciiz				"FD"
TextLabel: .asciiz				"FT"
WordLabel: .asciiz 				".word"
DataHeader: .asciiz 				".data"
TextHeader: .asciiz 				".text"
Tab:	.asciiz 				"\t"
NL:	.asciiz 				"\n"
Colon:	.asciiz 				":"
Comma:	.asciiz 				","
Space: .asciiz 					" "
OpenPara:	.asciiz 			"("
ClosePara:	.asciiz 			")"

				
	.text
		
PreDataLoop:	li 	$v0, 4				#Prepares for outputting of the .data segment
		la 	$a0, Tab
		syscall
		
		la 	$a0, DataHeader			#Prints the ".data" string
		syscall
		
		la 	$a0, NL				#Appends a '\n' to the output
		syscall
		
		la 	$s1, FibText			#Loads Data's address into $s1
		la 	$s2, Offset			#Loads Offset's address into $s2
		la 	$s3, FibData
		
DataLoop:	beq 	$s3, $s1, PreTextLoop		#Prints each element of the .data array with its own label
		
		li 	$v0, 4				#Prints the standard DataLabel string
		la 	$a0, DataLabel
		syscall
		
		li	$v0, 1
		la 	$a0, ($s3)			#Appends the current address to the output
		syscall
		
		li 	$v0, 4
		la 	$a0, Colon			#Appends a ':' to the output
		syscall
		
		la 	$a0, Tab			#Appends a '\t' to the output
		syscall
		
		la 	$a0, WordLabel			#Appends ".word" to the output
		syscall
		
		la 	$a0, Tab			#Appends a '\t' to the output
		syscall
		
		li 	$v0, 1				#Appends the value at the current address of FibData to the output
		lw 	$a0, FibData($s3)
		syscall
		
		li 	$v0, 4				#Appends a ',' to the output
		la 	$a0, Comma
		syscall
	
		la 	$a0, NL				#Appends a '\n' to the output
		syscall
		
		addi $s3, $s3, 4			#Increments the address and jumps to the top of the loop
		j 	DataLoop
		
PreTextLoop:	li 	$v0, 4			#Prepares for outputting the .text segment
		la 	$a0, Tab		#Appends a '\t' to the output
		syscall
		
		la 	$a0, TextHeader		#Appends the ".text" string to the output
		syscall
		
		la 	$a0, NL			#Appends a '\n' to the output
		syscall
		
		li	$s3, 12288	
		
		j 	TextLoop
		
TextLoop:	beq 	$s1, $s2, Exit		#Handles printing the label for each line of text
		
		
		li 	$v0, 4
		la 	$a0, TextLabel		#Prints the standard Text segment label to each line
		syscall
		
		li 	$v0, 1
		la 	$a0, ($s3)		#Prints the current address starting from 0x3000
		syscall
		
		li 	$v0, 4
		la 	$a0, Colon		#Prints a ':' to the output
		syscall
		
		la 	$a0, Tab		#Prints a '\t' to the output
		syscall
		
		j 	MainLoop		#Jumps to the main loop
				
MainLoop:
		beq 	$s1, $s2, Exit		#If $s1 is ever incremented to be equal to $s2, the loop ends
		lw 	$s0, ($s1)			#Loads the value from $s1 into $t0
		srl 	$s5, $s0, 26		#Converts $t0 into the opcode by performing a shift-right logical for 26 bits
		beq 	$s5, 0, Rtype		#If opcode = 0, move to Rtype
		beq 	$s5, 17, PrintNop
		j 	Standard			#If neither, proceed to standard operation
Rtype:
		lw 	$t2, ($s1)			
		sll 	$t2, $t2, 26		
		srl 	$s6, $t2, 26		#Retrieves the function code
		sll 	$t2, $s6, 2
		lw 	$t3, OffR($t2)		#Gets the Offset value from the R-type array
		li 	$v0, 4
		la 	$t4, NameR($t3)
		
		beq	$s6, 1, PrintNop	#Illegal R-type instructions
		beq	$s6, 5, PrintNop
		beq	$s6, 14, PrintNop
		beq	$s6, 20, PrintNop
		beq	$s6, 21, PrintNop
		beq	$s6, 22, PrintNop
		beq	$s6, 23, PrintNop
		beq	$s6, 28, PrintNop
		beq	$s6, 29, PrintNop
		beq	$s6, 30, PrintNop
		beq	$s6, 31, PrintNop
		beq	$s6, 40, PrintNop
		beq	$s6, 41, PrintNop
		beq	$s6, 44, PrintNop
		beq	$s6, 45, PrintNop
		beq	$s6, 46, PrintNop
		beq	$s6, 47, PrintNop
		beq	$s6, 53, PrintNop
		bge 	$s6, 55, PrintNop
		
		add	$a0, $t4, $0
		syscall				#Prints the name which corresponds to the function code
		
		la 	$a0, Tab		#Prints '\t' to the output
		syscall
		
		beq 	$s6, 12, Continue	#Special instructions
		beq	$s6, 13, Continue
		beq	$s6, 15, Continue
		
		beq 	$s6, 8, JumpRegFormat
		beq	$s6, 17, GetRS		#For instructions where rs comes first
		beq	$s6, 19, GetRS
		beq	$s6, 24, GetRS
		beq	$s6, 25, GetRS
		beq	$s6, 26, GetRS
		beq	$s6, 27, GetRS
		beq	$s6, 48, GetRS
		beq	$s6, 49, GetRS
		beq	$s6, 50, GetRS
		beq	$s6, 51, GetRS
		beq	$s6, 52, GetRS
		beq	$s6, 54, GetRS

GetRD:		sll 	$t0, $s0, 16		#Retrieves contents of rd
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		beq	$s6, 16, Continue	#For mfhi and mflo, which only use rd
		beq	$s6, 18, Continue
		
		la 	$a0, Comma		#Prints ',' to the output
		syscall
		
		la 	$a0, Space		#Prints ' ' to the output
		syscall
		
		beq	$s6, 0, GetRT		#For instructions where rs is not used or is preceded by rt
		beq	$s6, 2, GetRT
		beq	$s6, 3, GetRT
		beq	$s6, 4, GetRT
		beq	$s6, 6, GetRT
		beq	$s6, 7, GetRT
		
		j	GetRS			#Otherwise, move to RS procedure
		
GetRTComma:	li	$v0, 4			#For when RT is not the final register
		la	$a0, Comma		#Prints ',' to the output
		syscall
		
		la	$a0, Space		#Prints ' ' to the output
		syscall
		
		j	GetRS			#Moves to RS procedure
		
GetRS:		sll 	$t0, $s0, 6		#Retrieves contents of rs
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		beq	$s6, 9, Continue	#For functions where rs is the final register
		beq	$s6, 17, Continue
		beq	$s6, 19, Continue
		beq	$s6, 4, Continue
		beq	$s6, 6, Continue
		beq	$s6, 7, Continue
		
		la 	$a0, Comma		#Prints a ',' to the output
		syscall
		
		la 	$a0, Space		#Prints a ' ' to the output
		syscall
			
		j	GetRT			#Jumps to the rt procedure
		
GetRT:		sll 	$t0, $s0, 11		#Retrieves contents of rt
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		beq	$s6, 4, GetRTComma	#For special cases where RT is not the final register
		beq	$s6, 6, GetRTComma
		beq	$s6, 7, GetRTComma
		
		j 	Continue		#Proceed to finish this line of output
			
PrintNop:	li 	$v0, 4			#In case of illegal or unsupported instruction, print nop
		la 	$a0, Nop
		syscall
		j 	Continue		#Proceed to finish this line of output
		
Standard:	sll 	$t1, $s5, 2			#Converts $t0 into the Offset address by performing a shift-left logical for 2 bits
		lw 	$t2, Offset($t1)		#Loads the corresponding value from Offset into $t1
		
		beq	$s5, 16, PrintNop		#Handles illegal I-type instructions
		beq	$s5, 17, PrintNop
		beq	$s5, 18, PrintNop
		beq	$s5, 19, PrintNop
		beq	$s5, 20, PrintNop
		beq	$s5, 21, PrintNop
		beq	$s5, 22, PrintNop
		beq	$s5, 23, PrintNop
		beq	$s5, 24, PrintNop
		beq	$s5, 25, PrintNop
		beq	$s5, 26, PrintNop
		beq	$s5, 27, PrintNop
		beq	$s5, 28, PrintNop
		beq	$s5, 29, PrintNop
		beq	$s5, 30, PrintNop
		beq	$s5, 31, PrintNop
		beq	$s5, 39, PrintNop
		beq	$s5, 44, PrintNop
		beq	$s5, 45, PrintNop
		beq	$s5, 52, PrintNop
		beq	$s5, 55, PrintNop
		beq	$s5, 59, PrintNop
		beq	$s5, 60, PrintNop
		bge	$s5, 63, PrintNop
		
		li 	$v0, 4			#Prepares syscall to output a String
		la 	$a0, Name($t2)		#Loads the instruction name from Name into $a0 for output
		syscall				#Prints the output as a String
		
		la 	$a0, Tab		#Prints '\t' to the output
		syscall
		
		beq 	$s5, 3, JumpFormat	#For instructions with a jump target
		beq	$s5, 2, JumpFormat
		
		beq	$s5, 4, BranchFormat		#For instructions where RS comes first
		beq	$s5, 5, BranchFormat
		beq	$s5, 6, BranchFormat
		beq	$s5, 7, BranchFormat
		
		beq	$s5, 47, CacheOp	#Special case for cache op
		beq	$s5, 51, CacheOp
		
GetIRT:		sll 	$t0, $s0, 11		#Retrieves register rt from I-type instructions
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		la 	$a0, Comma		#Prints ',' to the output
		syscall
		
		la 	$a0, Space		#Prints ' ' to the output
		syscall
		
		beq	$s5, 15, GetI		#For instructions where an immediate follows RS
		
		beq	$s5, 4, JumpFormat	#For instructions where a label follows RS
		beq	$s5, 5, JumpFormat

		beq 	$s5, 35, OffsetFormat	#For instructions using the format rt, offset(base)
		beq 	$s5, 43, OffsetFormat
		beq	$s5, 32, OffsetFormat
		beq	$s5, 33, OffsetFormat
		beq	$s5, 34, OffsetFormat
		beq	$s5, 35, OffsetFormat
		beq	$s5, 36, OffsetFormat
		beq	$s5, 37, OffsetFormat
		beq	$s5, 38, OffsetFormat
		beq	$s5, 40, OffsetFormat
		beq	$s5, 41, OffsetFormat
		beq	$s5, 42, OffsetFormat
		beq	$s5, 43, OffsetFormat
		beq	$s5, 46, OffsetFormat
		beq	$s5, 48, OffsetFormat
		beq	$s5, 49, OffsetFormat
		beq	$s5, 50, OffsetFormat
		beq	$s5, 53, OffsetFormat
		beq	$s5, 54, OffsetFormat
		beq	$s5, 56, OffsetFormat
		beq	$s5, 57, OffsetFormat
		beq	$s5, 58, OffsetFormat
		beq	$s5, 61, OffsetFormat
		beq	$s5, 62, OffsetFormat
		
		
GetIRS:		sll 	$t0, $s0, 6		#Retrieves register rs from I-type instructions
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 6
		sra 	$t0, $t0, 4
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4			
		la 	$a0, Registers($t1)
		syscall
		
		la 	$a0, Comma		#Prints ',' to the output
		syscall
		
		la 	$a0, Space		#Prints ' ' to the output
		syscall
		
		beq	$s5, 4, GetIRT		#For instructions where RT follows RS
		beq	$s5, 5, GetIRT
		
		beq	$s5, 6, JumpFormat	#For Instructions where a label follows RS
		beq	$s5, 7, JumpFormat
		
GetI:		sll 	$t0, $s0, 16		#Retrieves a 16-bit immediate from I-type instructions
		sra 	$t0, $t0, 16
		li 	$v0, 1
		add 	$a0, $zero, $t0
		syscall
		
		j 	Continue		#Proceed to finish this line of output
		
CacheOp:	sll 	$t0, $s0, 11		#Special method for dealing with cache and pref instructions
		srl 	$t0, $t0, 27
		li 	$v0, 1
		add	$a0, $t0, $0
		syscall
		
		li	$v0, 4			#Prints ',' to the output
		la	$a0, Comma
		syscall
		
		la	$a0, Space		#Prints ' ' to the output
		syscall
		
		j	OffsetFormat		#Move to OffsetFormat to finish this module
		
OffsetFormat:	sll 	$t0, $s0, 16		#Method for handling instructions with the format rt, offset(base)
		srl 	$t0, $t0, 16
		li 	$v0, 1
		add 	$a0, $zero, $t0
		syscall
		
		li 	$v0, 4			#Prints '(' to the output
		la 	$a0, OpenPara
		syscall
		
		sll 	$t0, $s0, 6		#Retrieves the contents of rs
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		la 	$a0, Registers($t1)
		syscall
		
		la 	$a0, ClosePara		#Prints ')' to the output
		syscall
		
		j 	Continue		#Proceed to finish this line of output
		
JumpFormat:	sll 	$t0, $s0, 6		#Method for handling most jump instructions
		sra 	$t0, $t0, 4
		
		li 	$v0, 4			#Prints the standard text label
		la 	$a0, TextLabel
		syscall
		
		li 	$v0, 1			#Prints the address to be jumped to, appended to the label
		add 	$a0, $zero, $t0
		syscall
		
		j 	Continue		#Proceed to finish this line of output
		
JumpRegFormat:	sll 	$t0, $s0, 6		#Method for handling jump-to-register instructions
		srl 	$t0, $t0, 27
		sll	$t0, $t0, 2
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		j 	Continue		#Proceed to finish this line of output
		
BranchFormat:	sll 	$t0, $s0, 6		#Method for handling most branch instructions
		srl 	$t0, $t0, 27
		sll 	$t0, $t0, 6
		sra 	$t0, $t0, 4
		lw 	$t1, RegistersOffset($t0)
		li 	$v0, 4
		la 	$a0, Registers($t1)
		syscall
		
		la 	$a0, Comma		#Prints ',' to the output
		syscall
		
		la 	$a0, Space		#Prints ' ' to the output
		syscall
		
		sll 	$t0, $s0, 16		#Computes the destination to branch to from current PC+immediate, then prints TextLabel
		sra 	$t0, $t0, 16
		la 	$t1, ($s3)
		srl 	$t1, $t1, 2
		add 	$t1, $t1, $t0
		add 	$t1, $t1, 1
		sll 	$t1, $t1, 2
		li 	$v0, 4
		la 	$a0, TextLabel
		syscall
		
		li 	$v0, 1			#Prints destination to branch to, appended to the TextLabel
		la 	$a0, ($t1)
		syscall
		
		j 	Continue		#Proceed to finish this line of output
				
Continue:	la 	$v0, 4			#Prepares syscall to output a Character
		la 	$a0, NL			#Loads the newline character into $a0 for output
		syscall				#Prints the newline character
		
		addi 	$s1, $s1, 4		#Increments the Data address by 4
		addi	$s3, $s3, 4
		j 	TextLoop			#Jumps to the beginning of the loop
Exit:
		li 	$v0, 10			#Prepares syscall to terminate the program
		syscall				#Terminates program
